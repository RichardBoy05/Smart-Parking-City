/* 
  Sketch generated by the Arduino IoT Cloud Thing "Smart Parking City"
  https://create.arduino.cc/cloud/things/58daf9ae-462d-4ba6-aa55-5360ea421154 

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  int free_parking_slot_1_int;
  int free_parking_slot_2_int;
  int parkedVehiclesCount;
  int timed_parking_slot_1_int;
  int timed_parking_slot_2_int;
  bool free_parking_slot_1;
  bool free_parking_slot_2;
  bool timed_parking_slot_1;
  bool timed_parking_slot_2;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/

// ----------------- libraries ----------------- //

#include <Servo.h>
#include <EEPROM.h>
#include <NewPing.h>
#include "thingProperties.h"
#include "ParkingSensor.h"
#include "ledMatrixConfig.h"
#include <Arduino_LED_Matrix.h>

// ----------------- global variables ----------------- //

// connectivity

const int MAX_RETRY_ATTEMPTS = 5; // maximum reconnection attempts allowed
const int CONNECTION_CHECK_INTERVAL = 5000;
int connection_retry_count = 0;
unsigned long current_time = 0;
unsigned long last_connection_check_time = 0;

// built-in LED matrix

ArduinoLEDMatrix matrix;
const int LED_MATRIX_HEIGHT = 8;
const int LED_MATRIX_WIDTH = 12;

// pins

const int ENTRY_GATE_SENSOR = 1;
const int EXIT_GATE_SENSOR = 0;
const int SERVO_MOTOR = 10 ; // must be PWM
const int GREEN_LIGHT = 11;
const int RED_LIGHT = 12;
const int LDR = A5;
const int NIGHT_LAMP_1 = A2;
const int NIGHT_LAMP_2 = A3;
const int NIGHT_LAMP_3 = A4;
const int FREE_SLOT_SENSOR_1 = 6;
const int FREE_SLOT_SENSOR_2 = 4;
const int TIMED_SLOT_SENSOR_1 = 2;
const int TIMED_SLOT_SENSOR_2 = 8;
const int FREE_SLOT_LED_1 = 7;
const int FREE_SLOT_LED_2 = 5;
const int TIMED_SLOT_LED_1 = 3;
const int TIMED_SLOT_LED_2 = 9;

// free and timed parking slots

const float US_SENSOR_MAX_DISTANCE = 20.00; // max distance in cm

NewPing free_sonar_1 (FREE_SLOT_SENSOR_1, FREE_SLOT_SENSOR_1, US_SENSOR_MAX_DISTANCE);
NewPing free_sonar_2 (FREE_SLOT_SENSOR_2, FREE_SLOT_SENSOR_2 ,US_SENSOR_MAX_DISTANCE);
NewPing timed_sonar_1 (TIMED_SLOT_SENSOR_1, TIMED_SLOT_SENSOR_1, US_SENSOR_MAX_DISTANCE);
NewPing timed_sonar_2 (TIMED_SLOT_SENSOR_2, TIMED_SLOT_SENSOR_2, US_SENSOR_MAX_DISTANCE);

ParkingSensor free_parking_sensor_1(free_sonar_1, FREE_SLOT_LED_1, "F1");
ParkingSensor free_parking_sensor_2(free_sonar_2, FREE_SLOT_LED_2, "F2");
ParkingSensor timed_parking_sensor_1(timed_sonar_1, TIMED_SLOT_LED_1, "T1");
ParkingSensor timed_parking_sensor_2(timed_sonar_2, TIMED_SLOT_LED_2, "T2");

// toll parking

Servo servo;
boolean entryGate = false;
boolean exitGate = false;
unsigned long entry_detection_time = 0;
unsigned long entry_undetection_time = 0;
unsigned long exit_detection_time = 0;
unsigned long exit_undetection_time = 0;
int servo_state = 0; // 0 (servo down), 1 (servo opened from outside), 2 (servo opened from inside)
boolean servo_ready_to_close = false;
const int GATE_DETECTION_TIME = 5000; // time in milliseconds
const int TOTAL_PARKING_SLOTS = 5;
const int SERVO_DOWN_ANGLE = 6;
const int SERVO_UP_ANGLE = 103;


// automatic lights

const int LDR_CALIBRATION_TIME = 5000; // time in milliseconds
const int LDR_DETECTION_TIME = 2000; // time in milliseconds
const float DARKNESS_THRESHOLD_PERCENTAGE = 0.7;
unsigned long ldr_detection_time = 0;
unsigned long ldr_undetection_time = 0;
float darkness_threshold;

// ----------------- setup ----------------- //


void setup() {

  matrix.begin(); // initializes LED matrix
  matrix.renderBitmap(setup_matrix, LED_MATRIX_HEIGHT, LED_MATRIX_WIDTH); // setup LED matrix
   
  Serial.begin(9600); // initializes serial and wait for port to open
  delay(1500); // gives the chance to wait for a Serial Monitor without blocking if none is found

  initProperties(); // defined in thingProperties.h

  ArduinoCloud.begin(ArduinoIoTPreferredConnection, true); // connects to Arduino IoT Cloud
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();

  // pinModes

  pinMode(NIGHT_LAMP_1, OUTPUT);
  pinMode(NIGHT_LAMP_2, OUTPUT);
  pinMode(NIGHT_LAMP_3, OUTPUT);
  pinMode(LDR, INPUT); 
  pinMode(RED_LIGHT, OUTPUT);
  pinMode(GREEN_LIGHT, OUTPUT);
  pinMode(EXIT_GATE_SENSOR, INPUT);
  pinMode(ENTRY_GATE_SENSOR, INPUT);
  pinMode(FREE_SLOT_LED_1, OUTPUT);
  pinMode(FREE_SLOT_LED_2, OUTPUT);
  pinMode(TIMED_SLOT_LED_1, OUTPUT);
  pinMode(TIMED_SLOT_LED_2, OUTPUT);

  // circuit setup

  setupAutoLights();
  
  digitalWrite(RED_LIGHT, LOW);
  digitalWrite(GREEN_LIGHT, HIGH);
  digitalWrite(FREE_SLOT_LED_1, LOW);
  digitalWrite(FREE_SLOT_LED_2, LOW);
  digitalWrite(TIMED_SLOT_LED_1, LOW);
  digitalWrite(TIMED_SLOT_LED_2, LOW);

  parkedVehiclesCount = EEPROM.read(0);
  setServoAngle(SERVO_DOWN_ANGLE);

  matrix.renderBitmap(running_matrix, LED_MATRIX_HEIGHT, LED_MATRIX_WIDTH); // running LED matrix
  
  
}

// ----------------- loop ----------------- //

void loop() {
  
  if (!connectionHandler()){ // handles Arduino IoT Cloud connectivity
    return;
  }
  
  parkingAccessRegulator();
  autoLights();

  free_parking_sensor_1.detectParking();
  free_parking_sensor_2.detectParking();
  timed_parking_sensor_1.detectParking();
  timed_parking_sensor_2.detectParking();

}

// ----------------- additional functions ----------------- //

void setServoAngle(int angle){
  
  servo.attach(SERVO_MOTOR);
  servo.write(angle);
  delay(50); // small delay to allow the motor positioning before detaching it
  servo.detach();
  
}


boolean connectionHandler() {

 /**
 *
 * Handles the connection to Arduino Cloud.
 * 
 * Checks if the device is connected to Arduino Cloud. If not connected,
 * it retries a limited number of times. After those retries, it stops
 * trying to reconnect to prevent indefinite code freezing.
 * 
 * @return True: connected successfully or maximum retry attempts exceeded (code can flow);
 * @return False: attempting reconnection (code temporarily blocked).
 *
 */
  
  if (connection_retry_count < MAX_RETRY_ATTEMPTS) {
    ArduinoCloud.update();
  }

  unsigned long current_time = millis();

  
  if (current_time - last_connection_check_time >= CONNECTION_CHECK_INTERVAL) {
    // checks connection status at regular intervals

    last_connection_check_time = current_time;

    if (!ArduinoCloud.connected()) {
    
      if (connection_retry_count < MAX_RETRY_ATTEMPTS) {
        // increments retry count if still within retry attempts limit
        
        connection_retry_count++;
        matrix.renderBitmap(attempting_reconnection_matrix, LED_MATRIX_HEIGHT, LED_MATRIX_WIDTH); // attempting connection LED matrix
        
        return false; // trying to connect
      }

      matrix.renderBitmap(no_connection_matrix, LED_MATRIX_HEIGHT, LED_MATRIX_WIDTH); // attempting connection LED matrix
      return true; // exceeded maximum retry attempts
      
    } else {
      
      matrix.renderBitmap(running_matrix, LED_MATRIX_HEIGHT, LED_MATRIX_WIDTH); // running LED matrix
      connection_retry_count = 0; // reset retry count on successful connection
      
      return true; // successful connection
    }
    
  }

  return true; // no changes in connection status
}


void parkingAccessRegulator(){

 /**
 *
 * @brief Controls access to a parking area using sensor inputs and a servo motor for gate operation.
 * 
 * This function reads inputs from entry and exit gate sensors and controls the behavior of the 
 * access gate based on the detected conditions. The function manages the parking area occupancy 
 * and regulates gate operations accordingly. It utilizes timers to handle gate opening and closing 
 * events triggered by sensor detections.
 *
 */

  entryGate = !digitalRead(ENTRY_GATE_SENSOR);
  exitGate = !digitalRead(EXIT_GATE_SENSOR);

  if (servo_state == 0){ // bar is down

    if (parkedVehiclesCount >= TOTAL_PARKING_SLOTS){ // parking area is FULL, red light
      if (digitalRead(GREEN_LIGHT) == HIGH){
        digitalWrite(GREEN_LIGHT, LOW);
        digitalWrite(RED_LIGHT, HIGH);
      }
    }

    if (!entryGate && !exitGate){ // nothing is detected
      entry_detection_time = 0;
      exit_detection_time = 0;

      if (parkedVehiclesCount < TOTAL_PARKING_SLOTS){ // parking area not full, green light
        digitalWrite(GREEN_LIGHT, HIGH);
        digitalWrite(RED_LIGHT, LOW);
        return;
      }
        
    }

    if (entryGate && exitGate){ // if for some reason both the sensors are active, the gate is blocked the red light is activated
      entry_detection_time = 0;
      exit_detection_time = 0;
      digitalWrite(GREEN_LIGHT, LOW);
      digitalWrite(RED_LIGHT, HIGH);
      return;
    }

    if (parkedVehiclesCount < TOTAL_PARKING_SLOTS){ // parking area not full, green light
      digitalWrite(GREEN_LIGHT, HIGH);
      digitalWrite(RED_LIGHT, LOW);
    }

    // ENTRY GATE DETECTION

    if (entryGate && parkedVehiclesCount < TOTAL_PARKING_SLOTS){
      exit_detection_time = 0;

      if (entry_detection_time == 0){
        entry_detection_time = millis(); // starting timer...
      }

      if  (millis() - entry_detection_time >= GATE_DETECTION_TIME){ // timer expires, servo opened from OUTSIDE
     
        setServoAngle(SERVO_UP_ANGLE);
        servo_state = 1; // sets servo state to 1
        
      }

      return;
    }

    // EXIT GATE DETECTION
    
    if (exitGate){
      entry_detection_time = 0;
      
      if (exit_detection_time == 0){
        exit_detection_time = millis(); // starting timer...
      }

      if  (millis() - exit_detection_time >= GATE_DETECTION_TIME){ // timer expired, servo opened from INSIDE

        setServoAngle(SERVO_UP_ANGLE);
        servo_state = 2; // sets servo state to 2
      }

      return;
    }
    
  } else { // bar is up

    if (servo_state == 1){ // servo = 1 -> opened from outside -> we deal with the inside sensor

      if (exitGate && !servo_ready_to_close) { // exit gate must be activated first
        servo_ready_to_close = true;
      }

    if (servo_ready_to_close && exit_undetection_time == 0 && !exitGate) { // exitGate is no longer true, starting timer...
      exit_undetection_time = millis(); 
    }

    if (exit_undetection_time != 0 && millis() - exit_undetection_time >= GATE_DETECTION_TIME) { // timer expired

      servo_state = 0; // sets servo state to 0

      setServoAngle(SERVO_DOWN_ANGLE);
      
      servo_ready_to_close = false;   
      exit_undetection_time = 0;
      entry_detection_time = 0;   
      updateParkedVehiclesCount(1); // adds 1 vehicle
      
    }

  } else { // servo = 2 -> opened from inside -> we deal with the outside sensor

    if (entryGate && !servo_ready_to_close) { // entry gate must be activated first
        servo_ready_to_close = true;
        Serial.println("Servo is now ready to close");
      }

    if (servo_ready_to_close && entry_undetection_time == 0 && !entryGate) { // exitGate is no longer true, starting timer...
      entry_undetection_time = millis();
    }

    if (entry_undetection_time != 0 && millis() - entry_undetection_time >= GATE_DETECTION_TIME) { // timer expired
      
      servo_state = 0; // sets servo state to 0

      setServoAngle(SERVO_DOWN_ANGLE);
      
      servo_ready_to_close = false; 
      entry_undetection_time = 0;
      exit_detection_time = 0;
      updateParkedVehiclesCount(-1); // subtracts 1 vehicle
      
    }
      
    }   
    
  }
  
}

void setupAutoLights(){

 /**
 *
 * Turns off the night lights.
 * Reads the light level for LDR_CALIBRATION_TIME milliseconds,
 * gets the average value and sets the darkness_threshold accordingly.
 * NOTE: Ensure that this setup occurs in an environment representing
 * the typical expected LIGHT LEVEL; avoid executing it in darkness.
 *
 */

  digitalWrite(NIGHT_LAMP_1, LOW);
  digitalWrite(NIGHT_LAMP_2, LOW);
  digitalWrite(NIGHT_LAMP_3, LOW);

  int iterations = 0;
  int sum = 0;

  while (millis() < LDR_CALIBRATION_TIME){  
    sum += analogRead(LDR);
    iterations ++;  
  }
  
  darkness_threshold = (sum/iterations) * DARKNESS_THRESHOLD_PERCENTAGE;
}


void autoLights(){

/**
*
* Monitors the light level using an LDR sensor and activates 
* night lamps based on whether the light level remains below
* above a defined darkness threshold for a specified duration.
*
*/

  int light = analogRead(LDR);

  if (light < darkness_threshold) { // dark
        if (ldr_detection_time == 0) {
          ldr_detection_time = millis();
        }
        ldr_undetection_time = 0;
    
        if (millis() - ldr_detection_time >= LDR_DETECTION_TIME) {
          digitalWrite(NIGHT_LAMP_1, HIGH);
          digitalWrite(NIGHT_LAMP_2, HIGH);
          digitalWrite(NIGHT_LAMP_3, HIGH);
        }
      } else { // light
    
        if (ldr_undetection_time == 0) {
          ldr_undetection_time = millis();
        }
        ldr_detection_time = 0;
        if (millis() - ldr_undetection_time >= LDR_DETECTION_TIME) {
          digitalWrite(NIGHT_LAMP_1, LOW);
          digitalWrite(NIGHT_LAMP_2, LOW);
          digitalWrite(NIGHT_LAMP_3, LOW);
        }
  }
  
}

void updateParkedVehiclesCount(int change){

 /**
 *
 * Adds or subtract 1 to the parkedVehiclesCount cloud variable.
 * Ensures that parkedVehiclesCount is always >= 0
 * Stores the value in the EEPROM memory.
 *
 * @param change: +-1, indicates the change of vehicles parked.
 *
 */

  if (change != 1 && change != -1){ // preventing from typos in code
    Serial.println("Vehicle change can only be equal to +-1");
    return;
  }

  if (parkedVehiclesCount + change < 0){
    Serial.println("Something is wrong with the vehicles counting!");
    return;
  }

  parkedVehiclesCount += change;
  EEPROM.put(0, parkedVehiclesCount);
  
}